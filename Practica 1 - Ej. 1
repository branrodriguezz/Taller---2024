1.- Se desea procesar la información de las ventas de productos de un comercio (como máximo 50).
Implementar un programa que invoque los siguientes módulos:
a. Un módulo que retorne la información de las ventas en un vector. De cada venta se conoce el día de la venta, 
código del producto (entre 1 y 15) y cantidad vendida (como máximo 99 unidades). 
El código debe generarse automáticamente (random) y la cantidad se debe leer. El ingreso de las ventas finaliza 
con el día de venta 0 (no se procesa).
b. Un módulo que muestre el contenido del vector resultante del punto a).
c. Un módulo que ordene el vector de ventas por código.
d. Un módulo que muestre el contenido del vector resultante del punto c).
e. Un módulo que elimine, del vector ordenado, las ventas con código de producto entre dos valores que se ingresan como parámetros.
f. Un módulo que muestre el contenido del vector resultante del punto e).
g. Un módulo que retorne la información (ordenada por código de producto de menor a mayor) de cada código par de producto junto a la cantidad
total de productos vendidos.
h. Un módulo que muestre la información obtenida en el punto g).

program ej1p1;
const
	dimF = 50;
	corte = 0;
type
  comercio = 0..dimF;
  dias = 1..31;
  codigo = 0..15;
  unidades = 1..99;
  
  venta = record
    dia: dias;
    cod: codigo;
    cantv: unidades;
  end;
  
  superventas = array [1..dimF] of venta;
  
  lista = ^nodo;
  nodo = record
	ele: venta;
	sig: lista;
	end;

procedure leerventas (var v: venta);
begin
  writeln ('Dia');
  v.dia:= random (32);
  if (v.dia <> corte) then begin
		writeln ('Codigo');
		v.cod:= Random (16) + 1;
		writeln (v.cod);
		writeln ('Cantidad de ventas');
		readln (v.cantv);
		writeln (v.cantv);
    end;
end;

procedure cargarVenta (var sv: superventas; v: venta; var dimL: comercio);
begin
    if (dimL < dimF) then begin
      dimL:= dimL + 1;
      sv [dimL]:= v;
    end; 
end;

procedure procesarventas (var sv: superventas; var dimL: comercio);
var
  v: venta;
begin  
  leerventas (v);
  while (v.dia <> corte) do begin
    cargarVenta (sv,v, dimL);
    leerventas (v);
  end;
end;

procedure imprimirVenta (v: venta);
begin
  writeln ('Dia: ' , v.dia);
  writeln ('Codigo: ' , v.cod);
  writeln ('Cantidad de ventas: ' , v.cantv);
end;

procedure mostrarcontenido (sv: superventas; dimL: comercio);
var
  i: comercio;
begin
  for i:= 1 to dimL do begin
    imprimirVenta (sv[i]);
  end;
end;

procedure ordenarporcodigo (var sv: superventas; dimL: comercio);
var
  i,j: comercio;
  actual: codigo; 
begin
  for i:= 2 to dimL do begin //siempre 2?
    actual:= sv[i].cod;
    j:= i - 1;
    while (j > 0) and (sv[j].cod > actual) do
      begin
        sv[j+1].cod:= sv[j].cod;
        j:= j - 1;
      end;
    sv[j+1].cod:= actual;
end;

function buscarPosicion (sv: superventas; dimL: comercio ; elemABuscar: codigo): comercio;
var 
	pos: comercio;
begin
    pos:= 1;
    while (pos <= dimL) and (elemABuscar > sv[pos].cod) do
       pos:= pos + 1;
    if (pos > dimL) then 
		buscarPosicion:= 0;
    else 
		buscarPosicion:= pos;
end;
  
function BuscarPosicionDesde (sv: superventas; dimL, pos : integer; elemABuscar: codigo): comercio;
begin
    while (pos <= dimL) and (elemABuscar >= sv[pos].cod) do
       pos:= pos + 1;
    if (pos > dimL) then 
		BuscarPosicionDesde:= dimL;
	else 
		BuscarPosicionDesde:= pos - 1;
end;

procedure eliminarporcodigo (var v: vector; var dimL: rango3; valorInferior, valorSuperior: codigo);
var 
	posInferior, posSuperior, i,j: comercio; 
Begin
	posInferior:= buscarPosicion (v, dimL, valorInferior);
	if (posInferior <> 0) then begin
		posSuperior:= BuscarPosicionDesde (sv, dimL, posInferior, valorSuperior);
        for i:= posInferior to posSuperior do begin
			for j:= posInferior to (diml-1) do 
				v[j]:=v[j+1];
		end;
		dimL:= dimL - (posSuperior - posInferior + 1); 
    end;
end;

function cumple (codigo: codigo): boolean;
begin
	cumple:= (codigo MOD 2 = 0);
end;

procedure agregarAdelante (var l: lista; vent: venta);
var
 nuevo:lista;
begin
	new (nuevo); 
	nuevo^.elem:= vent; 
	nuevo^.sig:= nil; 
	if (l = nil) then 
		l:= nuevo
	else begin
        nuevo^.sig:= l;
        l:=nuevo;
    end;
end;

procedure generarLista (sv: superventas; dimL: comercio, var l: lista);
var
  var i: comercio; 
begin
	for i:= dimL downto 1 do begin //por que down to...ordenada por código de producto de menor a mayor.
		if (cumple (sv[i].cod)) then
		agregarAdelante (l,sv[i]);
	end;
end;

procedure mostrarconte (l: lista);
begin
	while (l <> nil) do begin
		writeln ('Dia: ' , l^.ele.dia);
		writeln ('Codigo: ' , l^.ele.cod);
		writeln ('Cantidad de ventas: ' , l^.ele.cantv);
	end;
end;

var
  l: lista;
  dimL: comercio;
  valorInferior,valorSuperior: codigo;
  v: vector;
  dimLv: integer;
begin
  Randomize;
  dimL:= 0;
  l:= nil;
  procesarventas (sv,dimL); // inciso A.
  mostrarcontenido (sv, dimL); //inciso B.
  ordenarporcodigo (sv, dimL); //inciso C.
  mostrarcontenido (sv, dimL); //inciso D;
  readln (valorInferior);
  readln (valorSuperior);
  eliminarporcodigo (sv,dimL,valorInferior, valorSuperior)); //inciso E;
  mostrarcontenido (sv, dimL); //inciso F;
  generarLista (v,dimL,l); //inciso G;
  mostrarconte (l); //inciso H;
end.
